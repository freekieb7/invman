version: '3.8'

services:
  # nginx:
  #   container_name: nginx
  #   build:
  #     context: ./nginx
  #     dockerfile: prod.Dockerfile
  #   restart: always
  #   volumes:
  #     - ./logs/nginx:/var/log/nginx/
  #   ports:
  #     - 80:80 # HTTP
  #     - 443:443 # HTTPS
  #   networks:
  #     - general-network
  #   environment:
  #     DOMAIN: ${DOMAIN}
  #     APP_DOMAIN: ${APP_DOMAIN}
  #     APP_DOMAIN_INTERNAL: app
  #     APP_PORT_INTERNAL: 3000
  #     API_DOMAIN: ${API_DOMAIN}
  #     API_DOMAIN_INTERNAL: api
  #     API_PORT_INTERNAL: 8080
  #     AUTH_DOMAIN: ${AUTH_DOMAIN}
  #     AUTH_DOMAIN_INTERNAL: auth
  #     AUTH_PORT_INTERNAL: 8080
  #     CHAT_DOMAIN: ${CHAT_DOMAIN}
  #     CHAT_DOMAIN_INTERNAL: chat
  #     CHAT_PORT_INTERNAL: 8080
  #     MONITOR_DOMAIN: ${MONITOR_DOMAIN}
  #     MONITOR_DOMAIN_INTERNAL: monitor
  #     MONITOR_PORT_INTERNAL: 3000
  #   depends_on:
  #     app:
  #       condition: service_healthy
  #     auth:
  #       condition: service_healthy
  #     api:
  #       condition: service_healthy
  #     monitor:
  #       condition: service_healthy
  #   healthcheck:
  #     test: [ "CMD", "service", "nginx", "status" ]
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # nginx-metrics-exporter:
  #   container_name: nginx-metrics-exporter
  #   image: nginx/nginx-prometheus-exporter
  #   depends_on:
  #     nginx:
  #       condition: service_started
  #   networks:
  #     - general-network
  #   command:
  #     - -nginx.scrape-uri=http://nginx/nginx_status

  # app:
  #   container_name: app
  #   build:
  #     context: ./app
  #     dockerfile: docker/prod.Dockerfile
  #     args:
  #       NEXT_PUBLIC_API_URL: https://${API_DOMAIN}
  #       NEXT_PUBLIC_CHAT_URL: wss://${CHAT_DOMAIN}
  #   networks:
  #     - general-network
  #   environment:
  #     AUTH_URL: https://${AUTH_DOMAIN}
  #     AUTH_CLIENT_ID: ${OAUTH_CLIENT_ID}
  #     AUTH_CLIENT_SECRET: ${OAUTH_CLIENT_SECRET}
  #     NEXT_TELEMETRY_DISABLED: 1
  #     NEXTAUTH_URL: https://${APP_DOMAIN}/api/auth
  #     NEXTAUTH_SECRET: ${NEXTAUTH_SECRET}
  #   healthcheck:
  #     test: curl -f http://localhost:3000/api/health || exit 1
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # api:
  #   container_name: api
  #   build:
  #     context: ./api
  #     dockerfile: prod.Dockerfile
  #   networks:
  #     - general-network
  #   depends_on:
  #     service-postgres:
  #       condition: service_healthy
  #   environment:
  #     ACCESS_TOKEN_SECRET: ${API_ACCESS_TOKEN_SECRET}
  #     APP_URL: https://${APP_DOMAIN}
  #     DATABASE_HOST: service-postgres
  #     DATABASE_USER: ${SERVICE_POSTGRES_USER}
  #     DATABASE_PASSWORD: ${SERVICE_POSTGRES_PASSWORD}
  #     DATABASE_PORT: ${SERVICE_POSTGRES_PORT}
  #     DATABASE_NAME: ${SERVICE_POSTGRES_DB}
  #   healthcheck:
  #     test: curl -f http://localhost:8080/health || exit 1
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # auth:
  #   container_name: auth
  #   build:
  #     context: ./auth/app
  #     dockerfile: prod.Dockerfile
  #   volumes:
  #     - ./auth/app:/app
  #   depends_on:
  #     auth-redis:
  #       condition: service_healthy
  #     auth-postgres:
  #       condition: service_healthy
  #   networks:
  #     - general-network
  #   environment:
  #     OAUTH_CLIENT_ID: ${OAUTH_CLIENT_ID}
  #     OAUTH_CLIENT_SECRET: ${OAUTH_CLIENT_SECRET}
  #     ACCESS_TOKEN_ISSUER: ${AUTH_DOMAIN}
  #     ACCESS_TOKEN_SECRET: ${API_ACCESS_TOKEN_SECRET}
  #     POSTGRES_HOST: auth-postgres
  #     POSTGRES_USER: ${AUTH_POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${AUTH_POSTGRES_PASSWORD}
  #     POSTGRES_PORT: ${AUTH_POSTGRES_PORT}
  #     POSTGRES_NAME: ${AUTH_POSTGRES_DB}
  #     REDIS_HOST: auth-redis
  #     REDIS_PORT: ${AUTH_REDIS_PORT}
  #     REDIS_PASSWORD: ${AUTH_REDIS_PASSWORD}
  #   healthcheck:
  #     test: curl -f http://localhost:8080/health || exit 1
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # auth-redis:
  #   container_name: auth-redis
  #   image: "redis:alpine"
  #   command: redis-server --requirepass ${AUTH_REDIS_PASSWORD}
  #   volumes:
  #     - ./auth/redis/data:/data
  #   networks:
  #     - general-network
  #   healthcheck:
  #     test: [ "CMD", "redis-cli", "ping" ]
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # auth-postgres:
  #   container_name: auth-postgres
  #   image: postgres:alpine
  #   environment:
  #     POSTGRES_USER: ${AUTH_POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${AUTH_POSTGRES_PASSWORD}
  #     POSTGRES_DB: ${AUTH_POSTGRES_DB}
  #   volumes:
  #     - ./auth/pg/data:/var/lib/postgresql/data
  #   networks:
  #     - general-network
  #   healthcheck:
  #     test:
  #       [
  #         "CMD-SHELL",
  #         "sh -c 'pg_isready -U ${AUTH_POSTGRES_USER} -d ${AUTH_POSTGRES_DB}'"
  #       ]
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # service-postgres:
  #   container_name: service-postgres
  #   image: postgres:alpine
  #   environment:
  #     POSTGRES_USER: ${SERVICE_POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${SERVICE_POSTGRES_PASSWORD}
  #     POSTGRES_DB: ${SERVICE_POSTGRES_DB}
  #   volumes:
  #     - ./service/pg/data:/var/lib/postgresql/data
  #   networks:
  #     - general-network
  #   healthcheck:
  #     test:
  #       [
  #         "CMD-SHELL",
  #         "sh -c 'pg_isready -U ${SERVICE_POSTGRES_USER} -d ${SERVICE_POSTGRES_DB}'"
  #       ]
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # chat:
  #   container_name: chat
  #   build:
  #     context: ./chat/app
  #     dockerfile: prod.Dockerfile
  #   networks:
  #     - general-network
  #   environment:
  #     AUTH_URL: https://${AUTH_DOMAIN}

  # prometheus:
  #   container_name: prometheus
  #   image: prom/prometheus
  #   networks:
  #     - general-network
  #   volumes:
  #     - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
  #     - prometheus_data:/prometheus

  mail:
    container_name: mail
    build:
      context: .
      dockerfile: mail/docker/prod.Dockerfile
      args:
        POSTMASTER_PASSWORD: ${POSTMASTER_PASSWORD}
    # Provide the FQDN of your mail server here (Your DNS MX record should point to this value)
    hostname: mail.invman.nl
    # More information about the mail-server ports:
    # https://docker-mailserver.github.io/docker-mailserver/latest/config/security/understanding-the-ports/
    # To avoid conflicts with yaml base-60 float, DO NOT remove the quotation marks.
    ports:
      - 25:25 # SMTP  (explicit TLS => STARTTLS)
      - 143:143 # IMAP4 (explicit TLS => STARTTLS)
      - 465:465 # ESMTP (implicit TLS)
      - 587:587 # ESMTP (explicit TLS => STARTTLS)
      - 993:993 # IMAP4 (implicit TLS)
    volumes:
      - ./nginx/certs/:/tmp/dms/custom-certs/:ro
      - ./mail/data/:/var/mail/
      - ./mail/state/:/var/mail-state/
      - ./mail/config/:/tmp/docker-mailserver/
      - ./logs/mail/:/var/log/mail/
      - /etc/localtime:/etc/localtime:ro
    environment:
      - SSL_TYPE=manual
      # Values should match the file paths inside the container:
      - SSL_CERT_PATH=/tmp/dms/custom-certs/invman.nl.crt
      - SSL_KEY_PATH=/tmp/dms/custom-certs/invman.nl.key
    restart: always
    stop_grace_period: 1m
    # Uncomment if using `ENABLE_FAIL2BAN=1`:
    # cap_add:
    #   - NET_ADMIN
    healthcheck:
      test: "ss --listening --tcp | grep -P 'LISTEN.+:smtp' || exit 1"
      timeout: 3s
      retries: 0
  # monitor:
  #   container_name: monitor
  #   build:
  #     context: ./monitor
  #     dockerfile: Dockerfile
  #   networks:
  #     - general-network
  #   volumes:
  #     - monitor_data:/var/lib/grafana
  #   environment:
  #     GF_INSTALL_PLUGINS: redis-datasource
  #   healthcheck:
  #     test: curl -f http://localhost:3000 || exit 1
  #     interval: 10s
  #     timeout: 3s
  #     retries: 3

  # networks:
  #   general-network:


  # volumes:
  #   prometheus_data:
  #   monitor_data:
