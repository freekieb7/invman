package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"invman/api/pkg/app/datasource/database/entity"
	"invman/api/pkg/gqlgen/generated"
	"invman/api/pkg/gqlgen/model"

	"github.com/google/uuid"
)

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	newItem := entity.Item{
		ID: uuid.New(),
		Attributes: func(input *model.ItemAttributesInput) entity.ItemAttributes {
			var attributes entity.ItemAttributes

			if input == nil {
				return attributes
			}

			for _, field := range input.Fields {
				attributes.Fields = append(attributes.Fields, entity.ItemAttributeField{
					ID:    uuid.New(),
					Name:  field.Name,
					Type:  field.Type,
					Value: field.Value,
				})
			}

			return attributes
		}(input.Attributes),
	}

	err := r.ItemRepository.Create(newItem)

	if err != nil {
		return nil, err
	}

	item, err := r.ItemRepository.Get(newItem.ID)

	if err != nil {
		return nil, err
	}

	return &model.Item{
		ID:        item.ID,
		GroupID:   item.GroupID,
		CreatedAt: item.CreatedAt,
		UpdatedAt: item.UpdatedAt,
		Attributes: func(entityAttributes entity.ItemAttributes) *model.ItemAttributes {
			var modelFields []model.ItemAttributeField

			for _, field := range entityAttributes.Fields {
				modelFields = append(modelFields, model.ItemAttributeField{
					ID:    field.ID,
					Name:  field.Name,
					Type:  field.Type,
					Value: field.Value,
				})
			}

			return &model.ItemAttributes{
				Fields: modelFields,
			}
		}(item.Attributes),
	}, nil
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id uuid.UUID) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteItem - deleteItem"))
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id uuid.UUID) (*model.Item, error) {
	panic(fmt.Errorf("not implemented: DeleteItem - deleteItem"))
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, limit *int, offset *int) ([]model.Item, error) {
	var modelItems []model.Item

	items, err := r.ItemRepository.List(limit, offset)

	if err != nil {
		return nil, err
	}

	for _, item := range items {

		var fields []model.ItemAttributeField

		for _, field := range item.Attributes.Fields {
			fields = append(fields, model.ItemAttributeField{
				ID:    field.ID,
				Name:  field.Name,
				Type:  field.Type,
				Value: field.Value,
			})
		}

		modelItems = append(modelItems, model.Item{
			ID: item.ID,
			Attributes: &model.ItemAttributes{
				Fields: fields,
			},
			CreatedAt: item.CreatedAt,
			UpdatedAt: item.UpdatedAt,
		})
	}

	return modelItems, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
