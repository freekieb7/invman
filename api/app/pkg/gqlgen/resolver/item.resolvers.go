package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"invman/api/pkg/app/datasource/database/entity"
	"invman/api/pkg/gqlgen/generated"
	gql "invman/api/pkg/gqlgen/model"
	"log"

	"github.com/google/uuid"
)

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input gql.CreateItemInput) (*gql.Item, error) {
	item := r.ItemFactory.New()

	item.ID = uuid.New()
	item.PID = input.Pid
	item.GroupID = input.GroupID

	for _, localCustomField := range input.LocalCustomFields {
		fieldId := uuid.NewString()

		if localCustomField.TextCustomField != nil {
			customField := localCustomField.TextCustomField

			textCustomField := r.TextCustomFieldFactory.New()
			textCustomField.CustomField.ID = fieldId
			textCustomField.CustomField.Translations.Default = customField.Field.Name
			textCustomField.OnEmptyValue = customField.OnEmptyValue
			textCustomField.TextCustomFieldValue = entity.TextCustomFieldValue{
				Value: customField.Value,
			}
		}
	}

	for _, globalCustomFieldValue := range input.GlobalCustomFieldsValues {
		if globalCustomFieldValue.TextCustomField != nil {
			customFieldValue := globalCustomFieldValue.TextCustomField
			item.GlobalCustomFieldsValues.V[customFieldValue.ID] = customFieldValue.Value
		}
	}

	err := r.ItemRepository.Create(item)

	if err != nil {
		return nil, err
	}

	return r.Resolver.Query().Item(ctx, item.ID)
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.ItemRepository.Delete(id)

	if err != nil {
		return false, err
	}

	return true, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id uuid.UUID) (*gql.Item, error) {
	var gqlItem gql.Item
	var gqlItemGroup gql.ItemGroup

	item, err := r.ItemRepository.Get(id)

	if err != nil {
		return nil, err
	}

	gqlItem.ID = item.ID
	gqlItem.Pid = item.PID
	gqlItem.CreatedAt = item.CreatedAt
	gqlItem.UpdatedAt = item.UpdatedAt

	if item.GroupID != nil {
		group, err := r.ItemGroupRepository.Get(*item.GroupID)

		if err != nil {
			return nil, err
		}

		gqlItemGroup.ID = group.ID
		gqlItemGroup.Name = group.Name
		gqlItemGroup.CreatedAt = group.CreatedAt
		gqlItemGroup.UpdatedAt = group.UpdatedAt

		gqlItem.Group = &gqlItemGroup
	}

	return &gqlItem, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, limit int, offset *int, filters []gql.ItemsFilter) ([]gql.Item, error) {
	var gqlItems []gql.Item

	MAX_LIMIT := 100
	if limit > MAX_LIMIT {
		return nil, fmt.Errorf("validation: limit may not exceed %d", MAX_LIMIT)
	}

	items, err := r.ItemRepository.List(limit, offset, filters)

	if err != nil {
		return nil, err
	}

	settings, err := r.SettingsRepository.Get()

	if err != nil {
		return nil, err
	}

	// DUMB SOLUTION: should fix in repository for better optimization
	for _, item := range items {
		var gqlItem gql.Item

		gqlItem.ID = item.ID
		gqlItem.Pid = item.PID
		gqlItem.CreatedAt = item.CreatedAt
		gqlItem.UpdatedAt = item.UpdatedAt

		// GROUP
		if item.GroupID != nil {
			var gqlItemGroup gql.ItemGroup

			group, err := r.ItemGroupRepository.Get(*item.GroupID)

			if err != nil {
				return nil, err
			}

			gqlItemGroup.ID = group.ID
			gqlItemGroup.Name = group.Name
			gqlItemGroup.CreatedAt = group.CreatedAt
			gqlItemGroup.UpdatedAt = group.UpdatedAt

			gqlItem.Group = &gqlItemGroup
		}

		// GLOBAL field
		for fieldId, field := range settings.ItemsCustomFields.V {
			if field, ok := field.(*entity.TextCustomField); ok {
				textCustomField := gql.TextCustomField{
					Field: &gql.CustomField{
						ID:   field.ID,
						Name: field.Translations.Default,
					},
					OnEmptyValue: field.OnEmptyValue,
				}

				if value, ok := item.GlobalCustomFieldsValues.V[fieldId]; ok {
					if text, ok := value.(string); ok {
						textCustomField.Value = &text
					}
				}

				gqlItem.GlobalCustomFields = append(gqlItem.GlobalCustomFields, textCustomField)
			}
		}

		// LOCAL fields
		for _, fieldWithValue := range item.LocalCustomFields.V {
			switch fieldWithValue.(type) {
			case *entity.TextCustomField:
				{
					textCustomField := fieldWithValue.(*entity.TextCustomField)
					gqlItem.LocalCustomFields = append(gqlItem.LocalCustomFields, gql.TextCustomField{
						Field: &gql.CustomField{
							ID:   textCustomField.ID,
							Name: textCustomField.Translations.Default,
						},
						OnEmptyValue: textCustomField.OnEmptyValue,
						Value:        textCustomField.Value,
					})
				}
			default:
				log.Printf("unexpected type %T", fieldWithValue)
			}

		}

		gqlItems = append(gqlItems, gqlItem)
	}

	return gqlItems, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
