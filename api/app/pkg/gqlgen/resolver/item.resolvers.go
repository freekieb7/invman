package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"invman/api/pkg/app/datasource/database/entity"
	"invman/api/pkg/gqlgen/generated"
	gql "invman/api/pkg/gqlgen/model"

	"github.com/google/uuid"
)

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input gql.CreateItemInput) (*gql.Item, error) {
	item := entity.Item{
		ID:      uuid.New(),
		PID:     input.Pid,
		GroupID: input.GroupID,
	}

	for _, field := range input.LocalFields {
		item.LocalFields.V = append(item.LocalFields.V, entity.LocalField{
			ID: uuid.New().String(),
			Translation: entity.FieldTranslation{
				Default: field.Name,
			},
			Type:  field.Type.String(),
			Value: field.Value,
		})
	}

	for _, fieldValue := range input.GlobalFieldValues {
		item.GlobalFieldValues.V = append(item.GlobalFieldValues.V, entity.GlobalFieldValue{
			FieldID: fieldValue.FieldID,
			Value:   fieldValue.Value,
		})
	}

	// if !item.IsValid() {
	// 	return nil, errors.New("validation: Item did not meet validation requirements")
	// }

	err := r.ItemRepository.Create(item)

	if err != nil {
		return nil, err
	}

	return r.Resolver.Query().Item(ctx, item.ID)
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.ItemRepository.Delete(id)

	if err != nil {
		return false, err
	}

	return true, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id uuid.UUID) (*gql.Item, error) {
	var gqlItem gql.Item
	var gqlItemGroup gql.ItemGroup

	item, err := r.ItemRepository.Get(id)

	if err != nil {
		return nil, err
	}

	item.CopyTo(&gqlItem)

	if item.GroupID != nil {
		group, err := r.ItemGroupRepository.Get(*item.GroupID)

		if err != nil {
			return nil, err
		}

		group.CopyTo(&gqlItemGroup)
		gqlItem.Group = &gqlItemGroup
	}

	if err != nil {
		return nil, err
	}

	return &gqlItem, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, limit int, offset *int, filters []gql.ItemsFilter) ([]gql.Item, error) {
	var gqlItems []gql.Item

	MAX_LIMIT := 100
	if limit > MAX_LIMIT {
		return nil, fmt.Errorf("validation: limit may not exceed %d", MAX_LIMIT)
	}

	items, err := r.ItemRepository.List(limit, offset, filters)

	if err != nil {
		return nil, err
	}

	settings, err := r.SettingsRepository.Get()

	if err != nil {
		return nil, err
	}

	// DUMB SOLUTION: should fix in repository for better optimization
	for _, item := range items {
		var gqlItem gql.Item

		item.CopyTo(&gqlItem)

		// GROUP
		if item.GroupID != nil {
			var gqlItemGroup gql.ItemGroup

			itemGroup, err := r.ItemGroupRepository.Get(*item.GroupID)

			if err != nil {
				return nil, err
			}

			itemGroup.CopyTo(&gqlItemGroup)
			gqlItem.Group = &gqlItemGroup
		}

		// GLOBAL FIELDS
		for _, globalField := range settings.GlobalFields.V {
			if !globalField.Enabled {
				continue
			}

			var value *string

			for _, itemFieldValueOnly := range item.GlobalFieldValues.V {
				if globalField.ID == itemFieldValueOnly.FieldID {
					value = itemFieldValueOnly.Value
					break
				}
			}

			gqlItem.GlobalFieldValues = append(gqlItem.GlobalFieldValues, gql.GlobalFieldValue{
				FieldID:   globalField.ID,
				FieldName: globalField.Translation.Default,
				Value:     value,
			})
		}

		gqlItems = append(gqlItems, gqlItem)
	}

	return gqlItems, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
