// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/google/uuid"
)

type CustomFieldUnion interface {
	IsCustomFieldUnion()
}

type CreateItemGroupInput struct {
	Name string `json:"name"`
}

type CreateItemInput struct {
	Pid                      string                        `json:"pid"`
	GroupID                  *uuid.UUID                    `json:"groupId,omitempty"`
	LocalCustomFields        []*CustomFieldsWithValueInput `json:"localCustomFields,omitempty"`
	GlobalCustomFieldsValues []*CustomFieldsValuesInput    `json:"globalCustomFieldsValues,omitempty"`
}

type CustomField struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type CustomFieldInput struct {
	Name string `json:"name"`
}

type CustomFieldsInput struct {
	TextCustomField *TextCustomFieldInput `json:"textCustomField,omitempty"`
}

type CustomFieldsValuesInput struct {
	TextCustomField *TextCustomFieldValueInput `json:"textCustomField,omitempty"`
}

type CustomFieldsWithValueInput struct {
	TextCustomField *TextCustomFieldInputWithValue `json:"textCustomField,omitempty"`
}

type InspectionStatus struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Value string `json:"value"`
}

type InspectionStatusInput struct {
	Name  *string `json:"name,omitempty"`
	Value string  `json:"value"`
}

type Item struct {
	ID                 uuid.UUID          `json:"id"`
	Pid                string             `json:"pid"`
	Group              *ItemGroup         `json:"group,omitempty"`
	LocalCustomFields  []CustomFieldUnion `json:"localCustomFields,omitempty"`
	GlobalCustomFields []CustomFieldUnion `json:"globalCustomFields,omitempty"`
	CreatedAt          time.Time          `json:"createdAt"`
	UpdatedAt          *time.Time         `json:"updatedAt,omitempty"`
}

type ItemGroup struct {
	ID        uuid.UUID  `json:"id"`
	Name      string     `json:"name"`
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

type ItemGroupsFilter struct {
	Subject  ItemGroupsFilterSubject `json:"subject"`
	Operator FilterOperator          `json:"operator"`
	Value    *string                 `json:"value,omitempty"`
}

type ItemsFilter struct {
	Subject  ItemsFilterSubject `json:"subject"`
	Operator FilterOperator     `json:"operator"`
	Value    *string            `json:"value,omitempty"`
}

type Settings struct {
	ModuleInspectionsActive bool           `json:"moduleInspectionsActive"`
	ItemCustomFields        []*CustomField `json:"itemCustomFields,omitempty"`
}

type TextCustomField struct {
	Field        *CustomField `json:"field"`
	Value        *string      `json:"value,omitempty"`
	OnEmptyValue *string      `json:"onEmptyValue,omitempty"`
}

func (TextCustomField) IsCustomFieldUnion() {}

type TextCustomFieldInput struct {
	Field        *CustomFieldInput `json:"field"`
	OnEmptyValue *string           `json:"onEmptyValue,omitempty"`
}

type TextCustomFieldInputWithValue struct {
	Field        *CustomFieldInput `json:"field"`
	OnEmptyValue *string           `json:"onEmptyValue,omitempty"`
	Value        *string           `json:"value,omitempty"`
}

type TextCustomFieldValueInput struct {
	ID    string  `json:"id"`
	Value *string `json:"value,omitempty"`
}

type UpdateActiveModulesInput struct {
	ModuleInspectionsActive *bool `json:"moduleInspectionsActive,omitempty"`
}

type FilterOperator string

const (
	FilterOperatorContains FilterOperator = "contains"
	FilterOperatorEquals   FilterOperator = "equals"
)

var AllFilterOperator = []FilterOperator{
	FilterOperatorContains,
	FilterOperatorEquals,
}

func (e FilterOperator) IsValid() bool {
	switch e {
	case FilterOperatorContains, FilterOperatorEquals:
		return true
	}
	return false
}

func (e FilterOperator) String() string {
	return string(e)
}

func (e *FilterOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOperator", str)
	}
	return nil
}

func (e FilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ItemGroupsFilterSubject string

const (
	ItemGroupsFilterSubjectName ItemGroupsFilterSubject = "name"
)

var AllItemGroupsFilterSubject = []ItemGroupsFilterSubject{
	ItemGroupsFilterSubjectName,
}

func (e ItemGroupsFilterSubject) IsValid() bool {
	switch e {
	case ItemGroupsFilterSubjectName:
		return true
	}
	return false
}

func (e ItemGroupsFilterSubject) String() string {
	return string(e)
}

func (e *ItemGroupsFilterSubject) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemGroupsFilterSubject(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemGroupsFilterSubject", str)
	}
	return nil
}

func (e ItemGroupsFilterSubject) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ItemsFilterSubject string

const (
	ItemsFilterSubjectGroup ItemsFilterSubject = "group"
)

var AllItemsFilterSubject = []ItemsFilterSubject{
	ItemsFilterSubjectGroup,
}

func (e ItemsFilterSubject) IsValid() bool {
	switch e {
	case ItemsFilterSubjectGroup:
		return true
	}
	return false
}

func (e ItemsFilterSubject) String() string {
	return string(e)
}

func (e *ItemsFilterSubject) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemsFilterSubject(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemsFilterSubject", str)
	}
	return nil
}

func (e ItemsFilterSubject) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
