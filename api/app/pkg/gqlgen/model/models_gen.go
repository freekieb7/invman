// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/google/uuid"
)

type CreateItemGroupInput struct {
	Name       string                    `json:"name"`
	Attributes *ItemGroupAttributesInput `json:"attributes,omitempty"`
}

type CreateItemInput struct {
	GroupID    *uuid.UUID           `json:"groupID,omitempty"`
	Attributes *ItemAttributesInput `json:"attributes,omitempty"`
}

type CustomField struct {
	ID    uuid.UUID       `json:"id"`
	Name  string          `json:"name"`
	Type  CustomFieldType `json:"type"`
	Value string          `json:"value"`
}

type CustomFieldInput struct {
	Name  string `json:"name"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

type Item struct {
	ID         uuid.UUID       `json:"id"`
	Group      *ItemGroup      `json:"group,omitempty"`
	Attributes *ItemAttributes `json:"attributes,omitempty"`
	CreatedAt  time.Time       `json:"createdAt"`
	UpdatedAt  *time.Time      `json:"updatedAt,omitempty"`
}

type ItemAttributeGeneral struct {
	Fields []CustomField `json:"fields,omitempty"`
}

type ItemAttributeGeneralInput struct {
	Fields []CustomFieldInput `json:"fields,omitempty"`
}

type ItemAttributeSpecific struct {
	Fields []CustomField `json:"fields,omitempty"`
}

type ItemAttributeSpecificInput struct {
	Fields []CustomFieldInput `json:"fields,omitempty"`
}

type ItemAttributes struct {
	Specific *ItemAttributeSpecific `json:"specific"`
	General  *ItemAttributeGeneral  `json:"general"`
}

type ItemAttributesInput struct {
	Specific *ItemAttributeSpecificInput `json:"specific,omitempty"`
	General  *ItemAttributeGeneralInput  `json:"general,omitempty"`
}

type ItemGroup struct {
	ID         uuid.UUID            `json:"id"`
	Name       string               `json:"name"`
	Attributes *ItemGroupAttributes `json:"attributes,omitempty"`
	CreatedAt  time.Time            `json:"createdAt"`
	UpdatedAt  *time.Time           `json:"updatedAt,omitempty"`
}

type ItemGroupAttributeGeneral struct {
	Fields []CustomField `json:"fields,omitempty"`
}

type ItemGroupAttributeSpecific struct {
	Fields []CustomField `json:"fields,omitempty"`
}

type ItemGroupAttributeSpecificInput struct {
	Fields []CustomFieldInput `json:"fields,omitempty"`
}

type ItemGroupAttributes struct {
	Specific *ItemGroupAttributeSpecific `json:"specific"`
}

type ItemGroupAttributesInput struct {
	Specific *ItemGroupAttributeSpecificInput `json:"specific,omitempty"`
}

type ItemGroupsFilter struct {
	Subject  ItemGroupsFilterSubject `json:"subject"`
	Operator FilterOperator          `json:"operator"`
	Value    *string                 `json:"value,omitempty"`
}

type ItemsFilter struct {
	Subject  ItemsFilterSubject `json:"subject"`
	Operator FilterOperator     `json:"operator"`
	Value    *string            `json:"value,omitempty"`
}

type CustomFieldType string

const (
	CustomFieldTypeString  CustomFieldType = "string"
	CustomFieldTypeInteger CustomFieldType = "integer"
	CustomFieldTypeFloat   CustomFieldType = "float"
)

var AllCustomFieldType = []CustomFieldType{
	CustomFieldTypeString,
	CustomFieldTypeInteger,
	CustomFieldTypeFloat,
}

func (e CustomFieldType) IsValid() bool {
	switch e {
	case CustomFieldTypeString, CustomFieldTypeInteger, CustomFieldTypeFloat:
		return true
	}
	return false
}

func (e CustomFieldType) String() string {
	return string(e)
}

func (e *CustomFieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomFieldType", str)
	}
	return nil
}

func (e CustomFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilterOperator string

const (
	FilterOperatorContains FilterOperator = "contains"
	FilterOperatorEquals   FilterOperator = "equals"
)

var AllFilterOperator = []FilterOperator{
	FilterOperatorContains,
	FilterOperatorEquals,
}

func (e FilterOperator) IsValid() bool {
	switch e {
	case FilterOperatorContains, FilterOperatorEquals:
		return true
	}
	return false
}

func (e FilterOperator) String() string {
	return string(e)
}

func (e *FilterOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOperator", str)
	}
	return nil
}

func (e FilterOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ItemGroupsFilterSubject string

const (
	ItemGroupsFilterSubjectName ItemGroupsFilterSubject = "name"
)

var AllItemGroupsFilterSubject = []ItemGroupsFilterSubject{
	ItemGroupsFilterSubjectName,
}

func (e ItemGroupsFilterSubject) IsValid() bool {
	switch e {
	case ItemGroupsFilterSubjectName:
		return true
	}
	return false
}

func (e ItemGroupsFilterSubject) String() string {
	return string(e)
}

func (e *ItemGroupsFilterSubject) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemGroupsFilterSubject(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemGroupsFilterSubject", str)
	}
	return nil
}

func (e ItemGroupsFilterSubject) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ItemsFilterSubject string

const (
	ItemsFilterSubjectGroup ItemsFilterSubject = "group"
)

var AllItemsFilterSubject = []ItemsFilterSubject{
	ItemsFilterSubjectGroup,
}

func (e ItemsFilterSubject) IsValid() bool {
	switch e {
	case ItemsFilterSubjectGroup:
		return true
	}
	return false
}

func (e ItemsFilterSubject) String() string {
	return string(e)
}

func (e *ItemsFilterSubject) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemsFilterSubject(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemsFilterSubject", str)
	}
	return nil
}

func (e ItemsFilterSubject) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
